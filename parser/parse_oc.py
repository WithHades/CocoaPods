import json
import os
import re
import subprocess

import chardet
from clang.cindex import Index, CursorKind


def decode_oct_str(string: str) -> str:
    """
    decode a string than contains octal characters.
    for example:
    string = "\\345\\244\\247\\345\\256\\266\\345\\245\\275\\343\\200\\202"
    return "大家好。"
    :param string: result of decoding by utf-8
    :return:
    """
    if len(string) != 0:
        model = re.findall(r"((\\\d{3})+)", string)
        for m in model:
            byte_m = b''
            for c in m[0].split("\\")[1:]:
                byte_m += int.to_bytes(int(c, 8), length=1, byteorder='little')
            try:
                str_m = str(byte_m, chardet.detect(byte_m).get('encoding'))
                string = string.replace(m[0], str_m)
            except Exception as e:
                print(e)
    return string


class clang:

    @staticmethod
    def __traverse_clang_ast__(json_data: dict) -> (set, set):
        """
        traverse the nodes and parser the method and string.
        :param json_data: the data of json format that is from the ast data which generated by clang.
        :return: (method_signs, strings)
        """
        method_signs, strings = set(), set()
        if "kind" in json_data:
            kind = json_data["kind"]
            if kind == "StringLiteral":
                if "value" in json_data:
                    string = decode_oct_str(json_data["value"][1:-1])
                    strings.add(string)
                return method_signs, strings
            if kind == "ObjCMethodDecl" and "mangledName" in json_data:
                method_signs.add(json_data["mangledName"])
        if "inner" in json_data:
            for inner in json_data["inner"]:
                ret_method_signs, ret_strings = clang.__traverse_clang_ast__(inner)
                method_signs = method_signs.union(ret_method_signs)
                strings = strings.union(ret_strings)
        return method_signs, strings

    @staticmethod
    def __parse_clang_ast__(data: str, data_len: int, global_vals, code_file: str) -> (set, set):
        """
        parser the ast data generated by clang.
        :param data: ast data.
        :param data_len: length of ast data.
        :param global_vals: glovals that contains logger and db collections.
        :param code_file: source code file.
        :return: (method_signs, strings)
        """
        start, end = 0, data_len
        method_signs, strings = set(), set()
        while start < end:
            try:
                ast = json.loads(data[start:end])
                ret_method_signs, ret_strings = clang.__traverse_clang_ast__(ast)
                method_signs = method_signs.union(ret_method_signs)
                strings = strings.union(ret_strings)
                start, end = end, data_len
            except json.decoder.JSONDecodeError as err:
                if err.msg == 'Extra data':
                    end = start + err.pos
                else:
                    global_vals.logger.error("Could not parser ast. file_path: %s, error: %s" % (code_file, err.msg))
                    break
        return method_signs, strings

    @staticmethod
    def parse_by_clang(global_vals, code_file: str) -> (set, set):
        """
        parser c/c++/objective-c code by clang.
        :param global_vals: glovals variables.
        :param code_file: source code file which wants to be parsed.
        :return: (method_signs, strings)
        """
        if not code_file.endswith(".m") and not code_file.endswith(".h") and not code_file.endswith(".c"):
            return
        pwd = os.getcwd()
        os.chdir(os.path.dirname(code_file))

        # parser ast
        cmd = global_vals.compiler + " -fsyntax-only -fno-color-diagnostics -ferror-limit=0 -Xclang -ast-dump=json {} >> ast_result.txt".format(code_file)
        subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).wait()
        if not os.path.exists("ast_result.txt"):
            global_vals.logger.error("Could not generate ast. file_path: %s." % code_file)
            return
        with open("ast_result.txt", "r", encoding="UTF-8") as f:
            data = f.read()
        os.remove("ast_result.txt")
        if "StringLiteral" not in data and "ObjCMethodDecl" not in data:
            global_vals.logger.error("Could not find StringLiteral or ObjCMethodDecl in ast file. file_path: %s." % code_file)
            return
        method_signs, strings = clang.__parse_clang_ast__(data, len(data), global_vals, code_file)

        # parser tokens
        cmd = global_vals.compiler + " -fsyntax-only -fno-color-diagnostics -ferror-limit=0 -Xclang -dump-tokens {} >> tokens_result.txt 2>&1".format(code_file)
        subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).wait()
        if not os.path.exists("tokens_result.txt"):
            global_vals.logger.error("Could not generate tokens. file_path: %s." % code_file)
        else:
            with open("tokens_result.txt", "r", encoding="UTF-8") as f:
                data = f.read()
            os.remove("tokens_result.txt")
            ret = re.findall(r"string_literal '\"([\s\S]*?)\"'.*Loc=<", data)
            strings = strings.union(set(ret))

        os.chdir(pwd)
        return method_signs, strings


class libclang:

    @staticmethod
    def __traverse_libclang_ast__(global_vals, cursor) -> (set, set):
        """
        traverse the libclang AST.
        :param global_vals:
        :param cursor: the node of ast.
        :return: (method_signs, strings)
        """
        try:
            kind = cursor.kind
        except:
            kind = None
        if kind == CursorKind.STRING_LITERAL:
            string = cursor.displayname[1:-1]
            string = decode_oct_str(string)
            return set(), {string}

        method_signs, strings = set(), set()
        if kind == CursorKind.OBJC_CLASS_METHOD_DECL or kind == CursorKind.OBJC_INSTANCE_METHOD_DECL:
            method_sign = "+" if kind == CursorKind.OBJC_CLASS_METHOD_DECL else "-"
            if cursor.lexical_parent.displayname != "":
                method_sign += "[{} {}]".format(cursor.lexical_parent.displayname, cursor.displayname)
            else:
                usr = cursor.get_usr()
                method_sign += "[{} {}]".format(usr[usr.find(")") + 1: usr.rfind(")")], cursor.displayname)
                method_signs.add(method_sign)

        # recursion traverse the children.
        for cur in cursor.get_children():
            ret_method_signs, ret_strings = libclang.__traverse_libclang_ast__(global_vals, cur)
            method_signs = method_signs.union(ret_method_signs)
            strings = strings.union(ret_strings)
        return method_signs, strings

    @staticmethod
    def parse_by_libclang(global_vals, code_file) -> (set, set):
        """
        parser c/c++/objective-c code by libclang & pyclang.
        :param global_vals: glovals variables.
        :param code_file: source code file which wants to be parsed.
        :return: (method_signs, strings)
        """
        index = Index.create()
        tu = index.parse(code_file)
        try:
            method_signs, strings = libclang.__traverse_libclang_ast__(global_vals, tu.cursor)
            return method_signs, strings
        except Exception as e:
            global_vals.logger.error("An error occured in traverse_libclang_ast, code_file: %s, error: %s", (code_file, e.args[0]))
            return set(), set()
