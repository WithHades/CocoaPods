import json
import os
import re
import subprocess

import chardet
from clang.cindex import Index, CursorKind, Config


def decode_oct_str(string: str) -> str:
    """
    decode a string than contains octal characters.
    for example:
    string = "\\345\\244\\247\\345\\256\\266\\345\\245\\275\\343\\200\\202"
    return "大家好。"
    :param string: result of decoding by utf-8
    :return:
    """
    if len(string) != 0:
        model = re.findall(r"((\\\d{3})+)", string)
        for m in model:
            byte_m = b''
            for c in m[0].split("\\")[1:]:
                byte_m += int.to_bytes(int(c, 8), length=1, byteorder='little')
            try:
                str_m = str(byte_m, chardet.detect(byte_m).get('encoding'))
                string = string.replace(m[0], str_m)
            except Exception as e:
                print(e)
    return string


class clang:

    def __init__(self, code_file: str, compiler: str = "clang", logger=None):
        """
        :param code_file: source code file that wants to be parsed.
        :param logger: logger instance.
        """
        self._code_file = code_file
        self._compiler = compiler
        self._logger = logger

        self._method_signs = set()
        self._strings = set()


    def _traverse_clang_ast(self, json_data: dict) -> None:
        """
        traverse the nodes and parser the method and string.
        :param json_data: the data of json format that is from the ast data which generated by clang.
        """
        if "kind" in json_data:
            kind = json_data["kind"]
            if kind == "StringLiteral":
                if "value" in json_data:
                    string = decode_oct_str(json_data["value"][1:-1])
                    self._strings.add(string)
                return
            if kind == "ObjCMethodDecl" and "mangledName" in json_data:
                self._method_signs.add(json_data["mangledName"])
        if "inner" in json_data:
            for inner in json_data["inner"]:
                self._traverse_clang_ast(inner)


    def _parse_clang_ast(self, data: str, data_len: int) -> None:
        """
        parser the ast data generated by clang.
        :param data: ast data.
        :param data_len: length of ast data.
        """
        start, end = 0, data_len
        while start < end:
            try:
                ast = json.loads(data[start:end])
                self._traverse_clang_ast(ast)
                start, end = end, data_len
            except json.decoder.JSONDecodeError as err:
                if err.msg == 'Extra data':
                    end = start + err.pos
                else:
                    self._logger.error("Could not parser ast. file_path: %s, error: %s" % (self._code_file, err.msg))
                    break


    def parse_by_clang(self):
        """
        parser c/c++/objective-c code by clang.
        """
        if not self._code_file.endswith(".m") and not self._code_file.endswith(".h") and not self._code_file.endswith(".c"):
            return self

        pwd = os.getcwd()
        os.chdir(os.path.dirname(self._code_file))

        try:
            # parser ast
            cmd = self._compiler + " -fsyntax-only -fno-color-diagnostics -ferror-limit=0 -Xclang -ast-dump=json {} >> ast_result.txt".format(self._code_file)
            subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).wait()
            if not os.path.exists("ast_result.txt"):
                self._logger.error("Could not generate ast. file_path: %s." % self._code_file)
                return self
            with open("ast_result.txt", "r", encoding="UTF-8") as f:
                data = f.read()
            os.remove("ast_result.txt")
            if "StringLiteral" not in data and "ObjCMethodDecl" not in data:
                self._logger.error("Could not find StringLiteral or ObjCMethodDecl in ast file. file_path: %s." % self._code_file)
                return self
            self._parse_clang_ast(data, len(data))

            # parser tokens
            cmd = self._compiler + " -fsyntax-only -fno-color-diagnostics -ferror-limit=0 -Xclang -dump-tokens {} >> tokens_result.txt 2>&1".format(self._code_file)
            subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE).wait()
            if not os.path.exists("tokens_result.txt"):
                self._logger.error("Could not generate tokens. file_path: %s." % self._code_file)
            else:
                with open("tokens_result.txt", "r", encoding="UTF-8") as f:
                    data = f.read()
                os.remove("tokens_result.txt")
                ret = re.findall(r"string_literal '\"([\s\S]*?)\"'.*Loc=<", data)
                self._strings = self._strings.union(set(ret))
        except Exception as e:
            self._logger.error("Could not run parse_by_clang. file_path: %s, error: %s" % (self._code_file, e.args[0]))
        os.chdir(pwd)
        return self

    def get_result(self) -> (set, set):
        return self._method_signs, self._strings


class libclang:

    def __init__(self, code_file: str, libclang: str, logger=None):
        """
        :param code_file: source code file that wants to be parsed.
        :param libclang: the file path to the libclang.
        :param logger: logger instance.
        """
        self._code_file = code_file
        self._logger = logger
        Config.set_library_file(libclang)

        self._method_signs = set()
        self._strings = set()

    def _traverse_libclang_ast(self, cursor) -> None:
        """
        traverse the libclang AST.
        :param cursor: the node of ast.
        :return: (method_signs, strings)
        """
        try:
            kind = cursor.kind
        except:
            kind = None
        if kind == CursorKind.STRING_LITERAL:
            string = cursor.displayname[1:-1]
            string = decode_oct_str(string)
            self._strings.add(string)
            return

        if kind == CursorKind.OBJC_CLASS_METHOD_DECL or kind == CursorKind.OBJC_INSTANCE_METHOD_DECL:
            method_sign = "+" if kind == CursorKind.OBJC_CLASS_METHOD_DECL else "-"
            if cursor.lexical_parent.displayname != "":
                method_sign += "[{} {}]".format(cursor.lexical_parent.displayname, cursor.displayname)
            else:
                usr = cursor.get_usr()
                method_sign += "[{} {}]".format(usr[usr.find(")") + 1: usr.rfind(")")], cursor.displayname)
                self._method_signs.add(method_sign)

        # recursion traverse the children.
        for cur in cursor.get_children():
            self._traverse_libclang_ast(cur)


    def parse_by_libclang(self):
        """
        parser c/c++/objective-c code by libclang & pyclang.
        :return: (method_signs, strings)
        """
        try:
            index = Index.create()
            tu = index.parse(self._code_file)
            self._traverse_libclang_ast(tu.cursor)
        except Exception as e:
            self._logger.error("An error occured in traverse_libclang_ast, code_file: %s, error: %s", (self._code_file, e.args[0]))
        return self


    def get_result(self) -> (set, set):
        return self._method_signs, self._strings
